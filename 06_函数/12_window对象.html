<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>window对象</title>
    <script>
        /* 
            window对象:
                - 在浏览器中, 浏览器为我们提供了一个window对象, 可以直接访问
                - window对象代表的是浏览器窗口, 通过该对象可以对浏览器窗口进行各种操作,
                    除此之外window对象还负责存储js中的内置对象和浏览器的宿主对象
                - window对象的属性可以通过window对象访问, 也可以直接访问
                - 函数就可以认为是window对象的方法
                - 向window对象中添加的属性会自动成为全局变量
        */
        // alert(window);
        // alert(123);
        // window.alert(123);
        // console.log("哈哈");
        // window.console.log("哈哈");

        // 向window对象添加的属性会变成全局变量
        // window.a = "window对象的属性a";
        // console.log(a);

        /* 
            var关键字用来声明变量, 作用和let关键字相同, 但是var声明的变量不具有块作用域
                - 在全局中使用var关键字声明的变量, 都会作为window对象的属性保存
                - 使用function关键字声明的函数, 都会作为window对象的方法保存
                - 使用let关键字声明的变量不会存储在window对象中, 而存在一个秘密的小地方(无法访问)
                - 当秘密的小地方和window对象存储了同一个变量时, 访问时是先找秘密的小地方
                - var关键字虽然没有块作用域, 但有函数作用域
                - 在局部作用域中, 如果没有使用var或let声明变量, 则变量会自动成为window对象的属性,
                    也就是全局变量
        */
        var b = "使用var声明的变量b";
        function fn() {
            alert("我是function声明的函数");
        }

        // console.log(window.b);
        // window.fn();

        let c = "使用let声明的变量c";
        // console.log(window.c); // 访问不到, 但不报错
        window.c = "window对象的属性c";
        // 先找秘密的小地方
        // console.log(c);

        function f1() {
            // var声明的变量具有函数作用域
            // var d = 50;
            // 没有var或let声明的变量成为全局变量
            d = 50;
        }
        f1();
        console.log(d);
    </script>
</head>
<body>
    
</body>
</html>